Locations
---------

Suppose mingw is in:
c:\mingw

Suppose source code is in:
c:\uimager


Mingw
-----

http://mingw.org/
https://osdn.net/projects/mingw/


FFMPEG command line versions
----------------------------

- ffmpeg.exe (ffmpeg.exe "stripped" of its debug symbols)
- ffmpeg_g.exe (ffmpeg.exe with debug symbols)


FFMPEG
------

1. Copy yasm.exe and nasm.exe to c:\mingw\bin

2. Copy latest c:\mingw\lib\gcc\mingw32\6.3.0\libgcc.a to /c/uimager/ffmpeg/mingw
               c:\mingw\lib\libmingwex.a to /c/uimager/ffmpeg/mingw
   
   To correctly link we have to remove the following object files, in visual studio command prompt do:
   $ lib -remove:pow.o -remove:strtoimax.o -remove:strtoumax.o -remove:strtof.o -remove:sinf.o -remove:cosf.o -remove:exp2f.o libmingwex.a
   $ rename libmingwex.lib libmingwex.a

3. Open msys console (call c:\uimager\ffmpeg\config_mingw_prompt.bat):
$ cd /c/uimager/ffmpeg
$ make distclean
$ ./config_mingw
$ make

ATTENTION: when updating the ffmpeg source make sure the offset to init 
m_nUnderlyingTransport with the lower_transport from RTSPState in rtsp.h 
is still correct!!


X264
----

Put library source to /src and extract it
(get stable src from https://code.videolan.org/videolan/x264/)

Apparently mingw doesn't support 32-bytes and 64-bytes stack alignment on Windows
(-mpreferred-stack-boundary=5 and -mpreferred-stack-boundary=6),
this effectively prevents the use of AVX instructions. In our code we prevent the use of AVX
by calling av_opt_set(). When recompiling X264 remember to disable newer SIMD instructions in
CAVRec::AddVideoStream()!
http://stackoverflow.com/questions/5983389/how-to-align-stack-at-32-byte-boundary-in-gcc
https://gcc.gnu.org/bugzilla/show_bug.cgi?id=49001

Patch the X264 configure file to have the default 16-bytes alignment:
if [ $compiler = GNU -a \( $ARCH = X86 -o $ARCH = X86_64 \) ] ; then
    #if cc_check '' -mpreferred-stack-boundary=6 ; then
    #    CFLAGS="$CFLAGS -mpreferred-stack-boundary=6"
    #    stack_alignment=64
    #elif cc_check '' -mstack-alignment=64 ; then
    #    CFLAGS="$CFLAGS -mstack-alignment=64"
    #    stack_alignment=64
    #elif [ $stack_alignment -lt 16 ] ; then
    #    if cc_check '' -mpreferred-stack-boundary=4 ; then
            CFLAGS="$CFLAGS -mpreferred-stack-boundary=4"
            stack_alignment=16
    #    elif cc_check '' -mstack-alignment=16 ; then
    #        CFLAGS="$CFLAGS -mstack-alignment=16"
    #        stack_alignment=16
    #    fi
    #fi

./configure --extra-cflags='-mstackrealign' --prefix=/mingw --enable-static --enable-strip --disable-cli --disable-avs --disable-gpac --disable-lsmash
(in config.h verify that #define STACK_ALIGNMENT 16)
make
make install
-> library: /mingw/lib/libx264.a copy to /c/uimager/ffmpeg/mingw


Is --enable-memalign-hack still necessary?
------------------------------------------

--enable-memalign-hack is not necessary because HAVE_ALIGNED_MALLOC is
defined with mingw and msvc toolchains so that _aligned_malloc,
_aligned_realloc and _aligned_free are used


Default stack alignment incompatibility: GCC uses 16 bytes, MSVC uses 4 bytes
-----------------------------------------------------------------------------

MSVC doesn't guarantee automatic stack alignment of variables, at most 
the variable will be aligned to the stacks alignment (generally 4 bytes 
on 32 bit systems). If you need special alignment, you have to use 
__declspec(align(x)), just like MSVC's SSE types(like __m128), else 
you'll need to use _aligned_malloc instead. 

A global solution is to edit your project so that when compiling with 
GCC on Windows, you pass the GCC option -mincoming-stack-boundary=2. 
Explanation: this tells GCC that the stack is only required to be 
aligned to 2^2=4 bytes, so that GCC now knows that it really must take 
extra care to honor the 16 byte alignment of fixed-size vectorizable 
Eigen types when needed.  

The problem with ffmpeg is that it assumes 16-byte alignment, and also 
has a lot of hand-written SSE assembly, either inline or in separate 
yasm sources. So that the above flag is not working, compilation will 
fail. To fix this problem use -mstackrealign which generates an 
alternate prologue/epilogue that realigns the runtime stack. This 
supports mixing legacy codes that keep a 4-byte aligned stack with 
modern codes that keep a 16-byte stack for SSE compatibility. The 
alternate prologue and epilogue are slower and bigger than the regular 
ones, and they require one dedicated register for the entire function. 
Nested functions encountered while -mstackrealign is on will generate 
warnings, and they will not realign the stack when called. 

ffmpeg is still crashing with the -mstackrealign option, I suppose there
is another alignment problem or just buggy SIMD routines, limit the SIMD
instructions to: 
AV_CPU_FLAG_MMX, AV_CPU_FLAG_MMXEXT, AV_CPU_FLAG_SSE 

with the following code:
unsigned int uiFlags = av_get_cpu_flags();
av_force_cpu_flags(uiFlags & ~( AV_CPU_FLAG_3DNOW     |
								AV_CPU_FLAG_3DNOWEXT  |
								AV_CPU_FLAG_SSE2      |
								AV_CPU_FLAG_SSE2SLOW  |
								AV_CPU_FLAG_SSE3      |
								AV_CPU_FLAG_SSE3SLOW  |
								AV_CPU_FLAG_SSSE3     |
								AV_CPU_FLAG_SSSE3SLOW |
								AV_CPU_FLAG_SSE4      |
								AV_CPU_FLAG_SSE42     |
								AV_CPU_FLAG_AESNI     |
								AV_CPU_FLAG_AVX       |
								AV_CPU_FLAG_AVXSLOW   |
								AV_CPU_FLAG_XOP       |
								AV_CPU_FLAG_FMA3      |
								AV_CPU_FLAG_FMA4      |
								AV_CPU_FLAG_AVX2      |
								AV_CPU_FLAG_BMI1      |
								AV_CPU_FLAG_BMI2));

and the following build options:
--disable-amd3dnow
--disable-amd3dnowext
--disable-sse2
--disable-sse3
--disable-ssse3
--disable-sse4
--disable-sse42
--disable-aesni
--disable-avx
--disable-xop
--disable-fma3
--disable-fma4
--disable-avx2

http://www.peterstock.co.uk/games/mingw_sse/


Possible MinGW Installation Manager Problems
--------------------------------------------

When running the MinGW Installation Manager it may happen that libintl-8.dll is missing:
Delete packages C:\MinGW\var\cache\mingw-get\packages\libintl-*
$ mingw-get install --reinstall msys-libintl
$ mingw-get install --reinstall mingw32-libintl


To update MinGW better to use the MSYS command line
---------------------------------------------------

$ mingw-get update
$ mingw-get upgrade


Demuxer vs. Parser
------------------

We do not need the Raw HEVC and H264 demuxers if we already have the RTSP demuxer 
(with HEVC and H264 parsers and decoders). 

The demuxer is the thing which takes a container (a single 1-D vector of bytes)
and splits (demuxes) these into several streams (1 or more audio streams,
1 or more video streams, ...).

The parser is the thing which takes a single stream as output by a demuxer and
splits it into proper frames (some demuxers already produce proper frames
so no parser is needed).
