- Note for unsigned 16 bits arithmetic with 32 bits compiler:
  w1 - w2 should be 0xFFFFU but below it is converted to
  the signed integer -1...
WORD w1 = 1U;
WORD w2 = 2U;
WORD w3 = 0x8000U;
WORD w4 = w1 - w2; 
if (w1 - w2 < w3)
    TRACE(_T("Not As expected!\n"));
if (!(w4 < w3))
    TRACE(_T("As expected\n"));
if (!((WORD)(w1 - w2) < w3))
    TRACE(_T("As expected\n"));
DWORD dw1 = 1U;
DWORD dw2 = 2U;
DWORD dw3 = 0x80000000U;
if (!(dw1 - dw2 < dw3))
    TRACE(_T("As expected\n"));
if (!((DWORD)(dw1 - dw2) < dw3))
    TRACE(_T("As expected\n"));

- UNICODE versions are not running on win95, win98 and Me machines,
  Microsoft Layer for Unicode (MSLU) needed...

- Starting with vs7 shlwapi.dll is needed, NT4 without ie5 does not have this!
  -> tell user to upgrade to ie5 or use good old vs6.

- To Fully Support Unicode in CEdit we have also to change the font of the dialog using the control:
  FONT 8, "MS Sans Serif", 0, 0, 0x1    ->      FONT 8, "MS Shell Dlg", 0, 0, 0x1

- Starting with MFC 7.x the CString comes from the Template Class CStringT.
  In VS6 the CString::Find() start index Documentation is wrong. The start index is always included
  in the search for MFC6,7.x, and 8!

- Swf files are limited by spec. to 16000 frames: Movement detection makes a new file after 15000 frames.
  Snapshot continues to add frames, all frames will be there, but the flash player will only play
  up to the given limit. The slider still works to view single frames...

- ContaCam runs in single instance because Micro Apache is killed when app closes
  and because the movement detection buffers are optimized for one instance

- Visited links are not shown on Safari for intranet addresses

- To declare the object pointed to by the pointer as const or volatile, use a declaration of the form:
  const    char *cpch;
  volatile char *vpch;
  To declare the value of the pointer — that is, the actual address stored in the pointer —
  as const or volatile, use a declaration of the form:
  char * const    pchc;
  char * volatile pchv;

- On an SMP system, normal memory references are not atomic.
  If two processors are simultaneously modifying the same memory location,
  one of the processor's updates will be lost. Performing atomic memory updates
  requires special processor instructions. X86 architectures provide the LOCK prefix
  to exclusively lock the memory bus for the duration of an instruction.
  RISC architectures (such as Mips, Alpha and PowerPC) provide a load-linked/store-conditional
  sequence of instructions for atomic updates. There are three Win32 APIs
  InterlockedIncrement, InterlockedDecrement and InterlockedExchange
  that use these instructions to perform atomic memory references
  in a portable fashion.

- All X86 CPUs are equipped with the ability to lock a specific memory address,
  preventing other system buses to read or modify it while the following instruction runs.
  The LOCK prefix to an assembly instruction causes the CPUs to assert the LOCK# signal,
  and practically ensures exclusive use of the memory address
  in multiprocessors / multi-thread environments.

  The LOCK prefix works only with the following instructions:

  BT, BTS, BTR, BTC   (mem, reg/imm)
  XCHG, XADD  (reg, mem / mem, reg)
  ADD, OR, ADC, SBB   (mem, reg/imm)
  AND, SUB, XOR   (mem, reg/imm)
  NOT, NEG, INC, DEC  (mem)

  Note: XCHG and XADD (and all the 'X' family of instructions) are planned to be multi-processor safe,
  and always asserts LOCK# regardless of the presence of the LOCK prefix.

  All threads and processes accessing the locked memory must 'play fair'.
  This means that any one accessing the memory without trying to lock the address
  will not be protected by other processes locking the same address.
  For example:
  Thread 1: lock inc ptr [edx]
  Thread 2: inc ptr [edx]
  If the two threads run simultaneously, thread 2 does not assert LOCK#.
  This means that it doesn't check if the memory pointed by edx is locked.
  This means the lock is useless in this matter.

- From the IA-32 reference entry for LOCK:
  "The LOCK prefix can be prepended only to the following instructions and
  only to those forms of the instructions where the destination operand is a
  memory operand: ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC,
  NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG. If the LOCK prefix is used with
  one of these instructions and the source operand is a memory operand, an
  undefined opcode exception (#UD) may be generated."
 
  Also, from the same page:
  "The integrity of the LOCK prefix is not affected by the alignment of the
  memory field. Memory locking is observed for arbitrarily misaligned fields."
 
  LOCK is intended to be used to implement synchronization primitives, which
  are a lot more complicated than a single MOV or INC.
  Yeah, it's easy to forget that you can't lock a mov. In real life you
  never have to, since you always make sure any data items you use in
  lock-free algorithms are aligned. If you actually had to do an
  unaligned atomic read, you can always force the issue with cmpxchg. 