- Starting with MFC 7.x the CString comes from the Template Class CStringT
- In VS6 the CString::Find() start index Documentation is wrong. The start
  index is always included in the search for all MFC versions!

  
LPTSTR CString::GetBuffer(int nMinBufLength)
--------------------------------------------

nMinBufLength is the minimum number of characters that the character 
buffer can hold. This value does not include space for a null 
terminator. If nMinBufLength is larger than the length of the current 
buffer, GetBuffer destroys the current buffer and replaces it with a 
null-terminated character buffer of (nMinBufLength + 1) * sizeof(TCHAR) 
bytes. 

Calling CString::GetBuffer() or the equivalent CString::GetBuffer(0) 
does not allocate memory, it simply returns a non-const pointer to the 
existing internal string data. The buffer size is 
(string length + 1) * sizeof(TCHAR) bytes. 

The pointer returned by GetBuffer is a dumb TCHAR*, it will not 
automatically reallocate on demand. 

Only if you use the pointer returned by GetBuffer to change the string 
contents, you must call ReleaseBuffer before you use any other member 
methods. 


void CString::ReleaseBuffer(int nNewLength = -1)
------------------------------------------------

nNewLength is the new length of the string in characters, not counting a 
null terminator. 

If you keep track of the string length yourself, you should not append 
the terminating null character. You must, however, specify the final 
string length when you release the buffer with ReleaseBuffer. If you do 
append a terminating null character, you should pass â€“1 for the length 
to ReleaseBuffer and ReleaseBuffer will perform a strlen on the buffer 
to determine its length. 


CStringA <-> CStringW
---------------------

When converting between CStringA <-> CStringW the CP_ACP code page is 
passed to MultiByteToWideChar() and WideCharToMultiByte(). This code 
page is localization dependent. I tested whether all 256 8 bit chars are 
converted from ANSI to Unicode and back. It seems to work even when the 
tested CP-1252 codepage defines 81, 8D, 8F, 90, and 9D as invalid. But I 
would not take that as granted, because I do not know the behaviour with 
all the other codepages and with different OS versions. So it's ok to 
store UTF-8 in CStringA but converting that to CStringW and then back to 
CStringA is not a good idea. When working with UTF-8 only use CStringA 
and do not convert it. 
