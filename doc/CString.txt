- Starting with MFC 7.x the CString comes from the Template Class CStringT
- In VS6 the CString::Find() start index Documentation is wrong. The start
  index is always included in the search for all MFC versions!

  
LPTSTR CString::GetBuffer(int nMinBufLength)
--------------------------------------------

nMinBufLength is the minimum number of characters that the character 
buffer can hold. This value does not include space for a null 
terminator. If nMinBufLength is larger than the length of the current 
buffer, GetBuffer destroys the current buffer and replaces it with a 
null-terminated character buffer of (nMinBufLength + 1) * sizeof(TCHAR) 
bytes. 

Calling CString::GetBuffer() or the equivalent CString::GetBuffer(0) 
does not allocate memory, it simply returns a non-const pointer to the 
existing internal string data. The buffer size is 
(string length + 1) * sizeof(TCHAR) bytes. 

The pointer returned by GetBuffer is a dumb TCHAR*, it will not 
automatically reallocate on demand. 

Only if you use the pointer returned by GetBuffer to change the string 
contents, you must call ReleaseBuffer before you use any other member 
methods. 


void CString::ReleaseBuffer(int nNewLength = -1)
------------------------------------------------

nNewLength is the new length of the string in characters, not counting a 
null terminator. 

If you keep track of the string length yourself, you should not append 
the terminating null character. You must, however, specify the final 
string length when you release the buffer with ReleaseBuffer. If you do 
append a terminating null character, you should pass â€“1 for the length 
to ReleaseBuffer and ReleaseBuffer will perform a strlen on the buffer 
to determine its length. 


CStringA <-> CStringW
---------------------

When converting between CStringA <-> CStringW the CP_THREAD_ACP code page 
is passed to MultiByteToWideChar() and WideCharToMultiByte(). This code 
page is localization dependent. I tested whether all 256 8 bit chars are 
converted from ANSI to Unicode and back. It seems to work even when the 
tested CP-1252 codepage defines 81, 8D, 8F, 90, and 9D as invalid. But I 
would not take that as granted, because I do not know the behaviour with 
all the other codepages and with different OS versions. So it's ok to 
store UTF-8 in CStringA but converting that to CStringW and then back to 
CStringA is not a good idea. When working with UTF-8 only use CStringA 
and do not convert it. 

Attention:

In versions of ATL up to and including ATL 3.0 in Visual C++ 6.0, string 
conversions in atlconv.h were always performed using the ANSI code page 
of the system (CP_ACP). Starting with ATL 7.0 in Visual C++ .NET, string 
conversions are performed using the default ANSI code page of the 
current thread. So CStringW <-> CStringA, T2A and A2T are all using 
CP_THREAD_ACP. 

LOCALE_USER_DEFAULT -> CP_THREAD_ACP:

In the "Region" dialog at the "Format" tab you can select that. This 
setting is per-user, changes are effective immediately. When a thread is 
created in Windows it takes the user default locale as initial thread 
locale. Note that the user default is supposed to be used for 
formatting and not for character conversion...!?!?

LOCALE_SYSTEM_DEFAULT -> CP_ACP:

This setting is found on the third tab of the "Region" dialog as 
"Language for non-Unicode programs". Changing the setting changes it for 
the entire machine and requires a reboot to take effect. 
